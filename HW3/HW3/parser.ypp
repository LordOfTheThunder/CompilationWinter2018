%{

#include <iostream>
#include <cstdlib>
#include <cassert>
#include <string>
using namespace std;

#include "StackStructs.h"
#include "output.hpp"
#include "symbolTable.hpp"
using namespace output;

int yylex();
void yyerror(const char *);
symbolTable* tables = NULL;
void CheckCorrectTypes(types _type1, string id2, types _type2);

%}

%token VOID
%token INT
%token BYTE
%token B
%token BOOL
%token STRUCT
%left AND
%left OR
%right NOT
%token TRUE
%token FALSE
%token RETURN
%token IF
%token ELSE
%token WHILE
%token BREAK
%token CONTINUE
%token SC
%token COMMA
%token PERIOD
%token LPAREN
%token RPAREN
%token LBRACE
%token RBRACE
%left ASSIGN
%nonassoc RELOP
%left BINOPMD
%left BINOPAS
%token ID
%token NUM
%token STRING


%%
Program: Structs Funcs  {
}

Funcs: FuncDecl Funcs {
}
	|	/*epsilon*/ ;

FuncDecl: FuncDecl1 FuncDecl2 {
	if ($2.ret_type != types_Undefined && $1.type != $2.ret_type) {
		// return type is different from function type
		errorMismatch($2.lineno);
		exit(0);
	}
	tables->popScope();
}

FuncDecl1: RetType ID LPAREN Formals RPAREN {
	tables->addFunction(typeToString($1.type), $2.str, $4.func_info, $1.lineno);
	$$.type = $1.type;
	$$.lineno = $1.lineno;
}

FuncDecl2: LBRACE Statements RBRACE {
	$$.ret_type = $2.ret_type;
	$$.lineno = $2.lineno;
}

Structs: StructsDecl Structs {
}
	| /*epsilon*/ {

	}

StructsDecl: STRUCT ID LBRACE StructMemList RBRACE SC {
	$$.str = string($2.str);
	tables->addStruct($$.str, $4.func_info, $1.lineno);
}

RetType: Type {
	$$.type = $1.type;
}
	| VOID {
		$$.type = types_Void;
	}

Formals: FormalsList {
}
	| /*epsilon*/ {

	}

FormalsList: FormalDecl {
	if ($1.struct_type != "") {
		// we have a struct type
		$$.func_info.insert($$.func_info.begin(),varPair($1.struct_type, $1.str));
	}
	else {
		$$.func_info.insert($$.func_info.begin(),varPair(typeToString($1.type), $1.str));
	}
}
	| FormalDecl COMMA FormalsList {
		$$.func_info = $3.func_info;
		if ($1.struct_type != "") {
			// we have a struct type
			$$.func_info.insert($$.func_info.begin(),varPair($1.struct_type, $1.str));
		}
		else {
			$$.func_info.insert($$.func_info.begin(),varPair(typeToString($1.type), $1.str));
		}
	}

FormalDecl: Type ID {
	tables->setLine($$.lineno);
	$$.type = $1.type;
	$$.str = $2.str;
}
	| StructType ID {
		$$.str = $2.str;
		$$.struct_type = $1.str;
		tables->setLine($$.lineno);
	}


StructMemList: StructMem {
	tables->setLine($$.lineno);
	$$.func_info.insert($$.func_info.begin(),varPair(typeToString($1.type), $1.str));
}
	| StructMem StructMemList {
		tables->setLine($$.lineno);
		$$.func_info = $2.func_info;
		$$.func_info.insert($$.func_info.begin(),varPair(typeToString($1.type), $1.str));
	}

StructMem: Type ID SC {
	tables->setLine($$.lineno);
	$$.type = $1.type;
	$$.str = $2.str;
}

Statements: Statement {
	if ($1.ret_type != types_Undefined) {
		$$.ret_type = $1.ret_type;
	}
	$$.lineno = $1.lineno;
}
	| Statements Statement {
		if ($2.ret_type != types_Undefined) {
			$$.ret_type = $2.ret_type;
		}
		$$.lineno = $2.lineno;
	}

StartScope: /*epsilon*/ {
	tables->addScope();
}

Statement: StartScope LBRACE Statements RBRACE {
	tables->popScope();
}

	| Type ID SC {
	tables->addVariable(typeToString($1.type), $2.str, $1.lineno);
}

	| StructType ID SC {

	}

	| STRUCT ID LBRACE StructMemList RBRACE SC {
		$$.str = string($2.str);
		tables->addStruct($$.str, $4.func_info, $1.lineno);
	}

	| Type ID ASSIGN Exp SC {
		tables->setLine($1.lineno);
		CheckCorrectTypes($1.type, $4.str, $4.type);
		tables->addVariable(typeToString($1.type), $2.str, $4.lineno);
	}

	| StructType ID ASSIGN Exp SC {

	}

	| ID ASSIGN Exp SC {
		tables->setLine($$.lineno);
		// Check ID exists
		if (!tables->existsId($1.str)) {
			errorUndef(tables->getLine(), $1.str);
			exit(0);
		}
		// Check correct type
		CheckCorrectTypes(stringToType((tables->getVariable($1.str))->getType()), $3.str, $3.type);
	}

	| ID PERIOD ID ASSIGN Exp SC {

	}

	| Call SC {

	}

	| RETURN SC {

	}

	| RETURN Exp SC {
		$$.ret_type = $2.type;
		$$.lineno = $1.lineno;
	}

	| IF LPAREN Exp RPAREN Statement {

	}

	| ELSE Statement %prec IF LPAREN Exp RPAREN Statement {

	}

	| WHILE LPAREN Exp RPAREN Statement {

	}

	| BREAK SC {

	}

	| CONTINUE SC {

	}


Call: ID LPAREN ExpList RPAREN {
	$$.str = $1.str;
	tables->callFunction($1.str, $3.func_info, $1.lineno);
}
	| ID LPAREN RPAREN {
		$$.str = $1.str;
		vector<varPair> t;
		tables->callFunction($1.str, t, $1.lineno);
	}

ExpList: Exp {

}
	| Exp COMMA ExpList {

	}

Type: INT {
	$$.type = types_Int;
}

	| BYTE {
		$$.type = types_Byte;
	}

	| BOOL {
		$$.type = types_Bool;
	}

StructType: STRUCT ID {
	$$.str = $2.str;
}

Exp: Exp BINOPAS Exp {

}	| Exp BINOPMD Exp {

	}

	| ID {
		$$.str = $1.str;
		$$.lineno = $1.lineno;
		// Check if function
		if (tables->getFunction($1.str) != NULL) {
			$$.func_info.insert($$.func_info.begin(),varPair((tables->getFunction($1.str))->getType(), $1.str));
		}
		// Check if variable
		else if (tables->getVariable($1.str) != NULL) {
			$$.func_info.insert($$.func_info.begin(),varPair((tables->getVariable($1.str))->getType(), $1.str));
		}
		else {
			// Not defined ...
			errorUndef($$.lineno, $$.str);
			exit(0);
		}

	}

	| ID PERIOD ID {

	}

	| Call {
		$$.str = $1.str;
		$$.lineno = $1.lineno;
	}

	| NUM {
		$$.str = $1.str;
		tables->setLine($$.lineno);
		$$.type = types_Int;
		$$.lineno = $1.lineno;
		$$.func_info.insert($$.func_info.begin(),varPair(typeToString(types_Int), $1.str));
	}

	| NUM B {
		$$.str = $1.str;
		int num = atoi($$.str.c_str());
		tables->setLine($$.lineno);
		if (num < 0 || num > 255) {
			errorByteTooLarge($$.lineno, $$.str);
			exit(0);
		}
		$$.type = types_Byte;
		$$.lineno = $1.lineno;
		$$.func_info.insert($$.func_info.begin(),varPair(typeToString(types_Byte), $1.str));
	}

	| STRING {
		$$.str = $1.str;
		$$.type = types_String;
		$$.lineno = $1.lineno;
		tables->setLine($$.lineno);
		$$.func_info.insert($$.func_info.begin(),varPair(typeToString(types_String), $1.str));
	}

	| TRUE {
		$$.str = $1.str;
		$$.type = types_Bool;
		$$.lineno = $1.lineno;
		$$.func_info.insert($$.func_info.begin(),varPair(typeToString(types_Bool), $1.str));
	}

	| FALSE {
		$$.str = $1.str;
		$$.type = types_Bool;
		$$.lineno = $1.lineno;
		$$.func_info.insert($$.func_info.begin(),varPair(typeToString(types_Bool), $1.str));
	}

	| NOT Exp {

	}

	| Exp AND Exp {

	}

	| Exp OR Exp {

	}

	| Exp RELOP Exp {

	}

%%

int main() {
	tables = new symbolTable();
	yyparse();
	delete tables;
	return 0;
}


void yyerror(const char *) {
	output::errorSyn(tables->getLine());
	exit(0);
}

void CheckCorrectTypes(types _type1, string id2, types _type2) {
		if (tables->getFunction(id2) == NULL && tables->getVariable(id2) == NULL && _type2 == types_Undefined) {
			// The parameter is neither a function or a variable. ERROR!
			errorUndef(tables->getLine(), id2);
			exit(0);
		}

		string type1 = typeToString(_type1);
		string type2 = typeToString(_type2);
		if (tables->getVariable(id2) != NULL && type2 == "undefined") {
			// Try to get the type from the table
			type2 = (tables->getVariable(id2))->getType();
		}
		if (tables->getFunction(id2) != NULL) {
			// This is a function. Treat it as a function
			type2 = (tables->getFunction(id2))->getType();
		}
		if (type1 == typeToString(types_Int) && type2 == typeToString(types_Byte)) {
			// It is allowed to assign byte to int
		}
		else if (type1 != type2) {
			errorMismatch(tables->getLine());
			exit(0);
		}
}